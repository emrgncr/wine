--- dlls/winex11.drv/window.c
+++ dlls/winex11.drv/window.c
@@ -1062,18 +1068,35 @@ void update_net_wm_states( struct x11drv_win_data *data )
     style = GetWindowLongW( data->hwnd, GWL_STYLE );
     if (style & WS_MINIMIZE)
         new_state |= data->net_wm_state & ((1 << NET_WM_STATE_FULLSCREEN)|(1 << NET_WM_STATE_MAXIMIZED));
-    if (is_window_rect_full_screen( &data->whole_rect ))
+    monitor = fs_hack_monitor_from_hwnd( data->hwnd );
+    if ((!data->fs_hack || fs_hack_enabled( monitor )) && is_window_rect_full_screen( &data->whole_rect ))
     {
         if ((style & WS_MAXIMIZE) && (style & WS_CAPTION) == WS_CAPTION)
             new_state |= (1 << NET_WM_STATE_MAXIMIZED);
         else if (!(style & WS_MINIMIZE))
-            new_state |= (1 << NET_WM_STATE_FULLSCREEN);
+        {
+            if (!wm_is_steamcompmgr(data->display) || !fs_hack_enabled(monitor))
+                /* when fs hack is enabled, we don't want steamcompmgr to resize the window to be fullscreened */
+                new_state |= (1 << NET_WM_STATE_FULLSCREEN);
+        }
     }
     else if (style & WS_MAXIMIZE)
         new_state |= (1 << NET_WM_STATE_MAXIMIZED);
 
     ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
-    if (ex_style & WS_EX_TOPMOST)
+    if ((ex_style & WS_EX_TOPMOST) &&
+            /* mutter < 3.31 has a bug where a FULLSCREEN and ABOVE window when
+             * minimized will incorrectly show a black window.  this workaround
+             * should be removed when the fix is widely distributed.  see
+             * mutter issue #306. */
+            !(wm_is_mutter(data->display) && (new_state & (1 << NET_WM_STATE_FULLSCREEN))) &&
+
+            /* KDE refuses to allow alt-tabbing out of fullscreen+above
+             * windows. Other WMs (XFCE) don't make fullscreen (without above)
+             * windows appear above their panels. KDE still does the right
+             * thing with fullscreen-only windows, so let's comprimise by not
+             * setting above on KDE. */
+            !wm_is_kde(data->display))
         new_state |= (1 << NET_WM_STATE_ABOVE);
     if (ex_style & (WS_EX_TOOLWINDOW | WS_EX_NOACTIVATE))
         new_state |= (1 << NET_WM_STATE_SKIP_TASKBAR) | (1 << NET_WM_STATE_SKIP_PAGER);
@@ -2458,9 +2544,45 @@ void CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
     DWORD flags;
     COLORREF key;
     BOOL layered = GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED;
+    HMONITOR monitor;
 
     if (!data && !(data = X11DRV_create_win_data( hwnd, window_rect, client_rect ))) return TRUE;
 
+    monitor = fs_hack_monitor_from_rect(window_rect);
+    if(!wm_is_steamcompmgr(data->display) && !data->fs_hack && fs_hack_enabled(monitor) &&
+            fs_hack_matches_current_mode(monitor,
+                window_rect->right - window_rect->left,
+                window_rect->bottom - window_rect->top)){
+        RECT real_rect = fs_hack_real_mode(monitor);
+        RECT user_rect = fs_hack_current_mode(monitor);
+        POINT tl = virtual_screen_to_root(user_rect.left, user_rect.top);
+
+        TRACE("Enabling fs hack for %p, resizing the window to (%u,%u)-(%u,%u)\n", hwnd, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+        data->fs_hack = TRUE;
+        if(data->whole_window)
+            XMoveResizeWindow(data->display, data->whole_window, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+        if(data->client_window)
+            XMoveResizeWindow(data->display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+    }else if(data->fs_hack && (!fs_hack_enabled(monitor) ||
+            !fs_hack_matches_current_mode(monitor,
+                window_rect->right - window_rect->left,
+                window_rect->bottom - window_rect->top))){
+        TRACE("Disabling fs hack for %p\n", hwnd);
+        data->fs_hack = FALSE;
+        if(data->whole_window)
+            XMoveResizeWindow(data->display, data->whole_window,
+                    window_rect->left, window_rect->top,
+                    window_rect->right - window_rect->left,
+                    window_rect->bottom - window_rect->top);
+        if(data->client_window){
+            XMoveResizeWindow(data->display, data->client_window,
+                    data->client_rect.left - data->whole_rect.left,
+                    data->client_rect.top - data->whole_rect.top,
+                    data->client_rect.right - data->client_rect.left,
+                    data->client_rect.bottom - data->client_rect.top);
+        }
+    }
+
     /* check if we need to switch the window to managed */
     if (!data->managed && data->whole_window && is_window_managed( hwnd, swp_flags, window_rect ))
     {
--- dlls/winex11.drv/window.c
+++ dlls/winex11.drv/window.c
@@ -3033,6 +3033,9 @@ LRESULT CDECL X11DRV_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
         return clip_cursor_notify( hwnd, (HWND)wp, (HWND)lp );
     case WM_X11DRV_CLIP_CURSOR_REQUEST:
         return clip_cursor_request( hwnd, (BOOL)wp, (BOOL)lp );
+    case WM_X11DRV_RELEASE_CURSOR:
+        ungrab_clipping_window();
+        return 0;
     default:
         FIXME( "got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp );
         return 0;
--- dlls/winex11.drv/window.c
+++ dlls/winex11.drv/window.c
@@ -1085,8 +1086,11 @@ void update_net_wm_states( struct x11drv_win_data *data )
         else if (!(style & WS_MINIMIZE))
         {
             if (!wm_is_steamcompmgr(data->display) || !fs_hack_enabled(monitor))
+            {
                 /* when fs hack is enabled, we don't want steamcompmgr to resize the window to be fullscreened */
+                net_wm_bypass_compositor = 1;
                 new_state |= (1 << NET_WM_STATE_FULLSCREEN);
+            }
         }
     }
     else if (style & WS_MAXIMIZE)
--- dlls/winex11.drv/window.c
+++ dlls/winex11.drv/window.c
@@ -1170,7 +1177,8 @@ void update_net_wm_states( struct x11drv_win_data *data )
             if (!wm_is_steamcompmgr(data->display) || !fs_hack_enabled(monitor))
             {
                 /* when fs hack is enabled, we don't want steamcompmgr to resize the window to be fullscreened */
-                net_wm_bypass_compositor = 1;
+                if (is_window_rect_full_virtual_screen( &data->whole_rect ))
+                    net_wm_bypass_compositor = 1;
                 new_state |= (1 << NET_WM_STATE_FULLSCREEN);
             }
         }
--- dlls/winex11.drv/window.c
+++ dlls/winex11.drv/window.c
@@ -1537,9 +1538,21 @@ static void sync_window_position( struct x11drv_win_data *data,
 
     set_size_hints( data, style );
     set_mwm_hints( data, style, ex_style );
+    /* KWin doesn't allow moving a window with _NET_WM_STATE_FULLSCREEN set. So we need to remove
+     * _NET_WM_STATE_FULLSCREEN before moving the window and restore it later */
+    if (wm_is_kde( data->display ) && is_window_rect_full_screen( &data->whole_rect ))
+    {
+        original_rect = data->whole_rect;
+        SetRectEmpty( &data->whole_rect );
+    }
     update_net_wm_states( data );
     data->configure_serial = NextRequest( data->display );
     XReconfigureWMWindow( data->display, data->whole_window, data->vis.screen, mask, &changes );
+    if (!IsRectEmpty( &original_rect ))
+    {
+        data->whole_rect = original_rect;
+        update_net_wm_states( data );
+    }
 #ifdef HAVE_LIBXSHAPE
     if (IsRectEmpty( old_window_rect ) != IsRectEmpty( &data->window_rect ))
         sync_window_region( data, (HRGN)1 );
--- dlls/winex11.drv/window.c
+++ dlls/winex11.drv/window.c
@@ -2644,7 +2644,7 @@ void CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
         if(data->whole_window)
             XMoveResizeWindow(data->display, data->whole_window, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
         if(data->client_window)
-            XMoveResizeWindow(data->display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+            XMoveResizeWindow(gdi_display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
     }else if(data->fs_hack && (!fs_hack_enabled(monitor) ||
             !fs_hack_matches_current_mode(monitor,
                 window_rect->right - window_rect->left,
@@ -2657,7 +2657,7 @@ void CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
                     window_rect->right - window_rect->left,
                     window_rect->bottom - window_rect->top);
         if(data->client_window){
-            XMoveResizeWindow(data->display, data->client_window,
+            XMoveResizeWindow(gdi_display, data->client_window,
                     data->client_rect.left - data->whole_rect.left,
                     data->client_rect.top - data->whole_rect.top,
                     data->client_rect.right - data->client_rect.left,
--- dlls/winex11.drv/window.c
+++ dlls/winex11.drv/window.c
@@ -2645,6 +2645,7 @@ void CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flag
             XMoveResizeWindow(data->display, data->whole_window, tl.x, tl.y, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
         if(data->client_window)
             XMoveResizeWindow(gdi_display, data->client_window, 0, 0, real_rect.right - real_rect.left, real_rect.bottom - real_rect.top);
+        EnumChildWindows( hwnd, fs_hack_update_child_window_client_surface, TRUE );
     }else if(data->fs_hack && (!fs_hack_enabled(monitor) ||
             !fs_hack_matches_current_mode(monitor,
                 window_rect->right - window_rect->left,
