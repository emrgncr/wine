--- dlls/winex11.drv/settings.c
+++ dlls/winex11.drv/settings.c
@@ -36,15 +36,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11settings);
 
-struct x11drv_display_setting
-{
-    ULONG_PTR id;
-    BOOL placed;
-    RECT new_rect;
-    RECT desired_rect;
-    DEVMODEW desired_mode;
-};
-
 struct x11drv_display_depth
 {
     struct list entry;
@@ -172,12 +167,13 @@ void X11DRV_Settings_Init(void)
     depths = screen_bpp == 32 ? depths_32 : depths_24;
 
     nores_handler.name = "NoRes";
-    nores_handler.priority = 1;
+    nores_handler.priority = 0;
     nores_handler.get_id = nores_get_id;
     nores_handler.get_modes = nores_get_modes;
     nores_handler.free_modes = nores_free_modes;
     nores_handler.get_current_mode = nores_get_current_mode;
     nores_handler.set_current_mode = nores_set_current_mode;
+    nores_handler.convert_coordinates = NULL;
     X11DRV_Settings_SetHandler(&nores_handler);
 }
 
@@ -361,7 +357,7 @@ BOOL get_primary_adapter(WCHAR *name)
     return FALSE;
 }
 
-static int mode_compare(const void *p1, const void *p2)
+int mode_compare(const void *p1, const void *p2)
 {
     DWORD a_width, a_height, b_width, b_height;
     const DEVMODEW *a = p1, *b = p2;
@@ -774,7 +770,6 @@ static POINT get_placement_offset(const struct x11drv_display_setting *displays,
 
 static void place_all_displays(struct x11drv_display_setting *displays, INT display_count)
 {
-    INT left_most = INT_MAX, top_most = INT_MAX;
     INT placing_idx, display_idx;
     POINT min_offset, offset;
 
@@ -809,15 +804,6 @@ static void place_all_displays(struct x11drv_display_setting *displays, INT disp
     {
         displays[display_idx].desired_mode.u1.s2.dmPosition.x = displays[display_idx].new_rect.left;
         displays[display_idx].desired_mode.u1.s2.dmPosition.y = displays[display_idx].new_rect.top;
-        left_most = min(left_most, displays[display_idx].new_rect.left);
-        top_most = min(top_most, displays[display_idx].new_rect.top);
-    }
-
-    /* Convert virtual screen coordinates to root coordinates */
-    for (display_idx = 0; display_idx < display_count; ++display_idx)
-    {
-        displays[display_idx].desired_mode.u1.s2.dmPosition.x -= left_most;
-        displays[display_idx].desired_mode.u1.s2.dmPosition.y -= top_most;
     }
 }
 
--- dlls/winex11.drv/settings.c
+++ dlls/winex11.drv/settings.c
@@ -576,6 +576,15 @@ static LONG get_display_settings(struct x11drv_display_setting **new_displays,
             goto done;
         }
 
+        current_mode.dmSize = sizeof(current_mode);
+        if (!EnumDisplaySettingsExW(display_device.DeviceName, ENUM_CURRENT_SETTINGS, &current_mode, 0))
+            goto done;
+
+        displays[display_idx].old_rect.left = current_mode.u1.s2.dmPosition.x;
+        displays[display_idx].old_rect.top = current_mode.u1.s2.dmPosition.y;
+        displays[display_idx].old_rect.right = displays[display_idx].old_rect.left + current_mode.dmPelsWidth;
+        displays[display_idx].old_rect.bottom = displays[display_idx].old_rect.top + current_mode.dmPelsHeight;
+
         if (!dev_mode)
         {
             memset(&registry_mode, 0, sizeof(registry_mode));
@@ -590,22 +599,12 @@ static LONG get_display_settings(struct x11drv_display_setting **new_displays,
             displays[display_idx].desired_mode = *dev_mode;
             if (!(dev_mode->dmFields & DM_POSITION))
             {
-                memset(&current_mode, 0, sizeof(current_mode));
-                current_mode.dmSize = sizeof(current_mode);
-                if (!EnumDisplaySettingsExW(display_device.DeviceName, ENUM_CURRENT_SETTINGS, &current_mode, 0))
-                    goto done;
-
                 displays[display_idx].desired_mode.dmFields |= DM_POSITION;
                 displays[display_idx].desired_mode.u1.s2.dmPosition = current_mode.u1.s2.dmPosition;
             }
         }
         else
         {
-            memset(&current_mode, 0, sizeof(current_mode));
-            current_mode.dmSize = sizeof(current_mode);
-            if (!EnumDisplaySettingsExW(display_device.DeviceName, ENUM_CURRENT_SETTINGS, &current_mode, 0))
-                goto done;
-
             displays[display_idx].desired_mode = current_mode;
         }
 
@@ -672,6 +671,55 @@ static POINT get_placement_offset(const struct x11drv_display_setting *displays,
     if (!has_placed)
         return min_offset;
 
+    /* Try to place this adapter next to a placed adapter it was next to */
+    if (EqualRect(&displays[placing_idx].desired_rect, &displays[placing_idx].old_rect))
+    {
+        for (display_idx = 0; display_idx < display_count; ++display_idx)
+        {
+            if (!displays[display_idx].placed ||
+                IsRectEmpty(&displays[display_idx].old_rect) ||
+                IsRectEmpty(&displays[display_idx].new_rect))
+                continue;
+
+            /* Left or right */
+            if (displays[placing_idx].old_rect.top <= displays[display_idx].old_rect.bottom &&
+                displays[placing_idx].old_rect.bottom >= displays[display_idx].old_rect.top)
+            {
+                offset.y = 0;
+                /* Right */
+                if (displays[placing_idx].old_rect.left == displays[display_idx].old_rect.right)
+                    offset.x = displays[display_idx].new_rect.right - displays[display_idx].old_rect.right;
+                /* Left */
+                else if (displays[placing_idx].old_rect.right == displays[display_idx].old_rect.left)
+                    offset.x = displays[display_idx].new_rect.left - displays[display_idx].old_rect.left;
+                else
+                    continue;
+            }
+            /* Top or bottom */
+            else if (displays[placing_idx].old_rect.left <= displays[display_idx].old_rect.right &&
+                     displays[placing_idx].old_rect.right >= displays[display_idx].old_rect.left)
+            {
+                offset.x = 0;
+                /* Bottom */
+                if (displays[placing_idx].old_rect.top == displays[display_idx].old_rect.bottom)
+                    offset.y = displays[display_idx].new_rect.bottom - displays[display_idx].old_rect.bottom;
+                /* Top */
+                else if (displays[placing_idx].old_rect.bottom == displays[display_idx].old_rect.top)
+                    offset.y = displays[display_idx].new_rect.top - displays[display_idx].old_rect.top;
+                else
+                    continue;
+            }
+            else
+                continue;
+
+            /* Check if this offset will cause overlapping */
+            rect = displays[placing_idx].desired_rect;
+            OffsetRect(&rect, offset.x, offset.y);
+            if (!overlap_placed_displays(&rect, displays, display_count))
+                return offset;
+        }
+    }
+
     /* Try to place this display with each of its four vertices at every vertex of the placed
      * displays and see which combination has the minimum offset length */
     width = displays[placing_idx].desired_rect.right - displays[placing_idx].desired_rect.left;
